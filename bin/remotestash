#!/usr/bin/env python3
#  MIT Licence
#
#  Copyright (c) 2020 Brice Rosenzweig.
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#  
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#  
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
#  
#

__version__ = '2.0.0'

from zeroconf import ServiceBrowser, Zeroconf, ServiceInfo
import hashlib
import mimetypes
import urllib3
import ssl
import uuid
import socket
import os
from contextlib import closing
import time
import argparse
from http.server import BaseHTTPRequestHandler
from urllib import parse
from email.message import EmailMessage
from multipart import MultipartError, parse_form_data
from requests import Session
import pwd
import json
import sys
from pprint import pprint
import traceback
import http.client
import socketserver
import builtins

# certificated created with
#  openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout remotestash-key.pem -out remotestash-cert.pem
# These need to be the same as the file remotestash-key and remotestash-cert that will be used by the ios app
# This is not intended to be highly secure, as clearly the key is available freely, but just to ensure
# ssl communication between the ios App, servers and/or cli commands

# content of file remotestash-key.pem
cert_remotestash_key = '''-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDhThz9C8oU30YU
1LTo37NLVUWVFG+W+DiEfFLChMDnTYjjcw2Z3ncUwAjDAEQ8ljc0t5Qh2IjdBFr4
ROQWH/fXue4MLGmq+cdxD/RITXX6LWUbVz/c1yXaxjGLSL/FZzpDpKzmv+geHVCi
+di/8W1ZbFbwLhj5o/FxXoIU0iD76Q3l7ymeSszEs/XTbNWHOhGmMf+fwvqBK2eh
uw3IHtAlK+apJvUaKlBKmSiHrhbQyH0VaM0zKTi8pFDV3yA+1aEPUOZkXC4qu30X
0j/ZP+j/UvNMyALX8RLaG55EB0NgCk/Cj2Zft8VdupP3ot/ZlTtrC41Lj2gwT1ym
5W5GIXM5AgMBAAECggEBAIO794khTov7rG9bm1eaDKxcdG3hYAnGos0cIAuqMVxM
4mATEn3ILJpOWhEiY8OFFUxWll9fy05nUIVfSnmBQZm6Fey6PyKAH1QFPxDTccrQ
phBhaG7IwVJ0ld1ZsP9MBy4r6AiXZrHM9CwGp+w6znP9u6t9WI8Gg5KE7swbvLtt
BR6bXBlxMqGCtTChYfGUj2pUWZtNSUHSjZruAOIGXVDvc5PwwwqZVBf/JvDRWSm0
QAoI6RlEBgG9aBBWYqnEHyWt/2Fj5Vexk2k+yYq15fuQgCq0ZsMJ+Pc4XcOEBU9/
lIxl50ujBjiuikBniDuPZr73WUbKXEVnma5XSilxrJ0CgYEA8lITd0NjCD5Cr0Sq
tOj3v86qYJAglnF6Wp7u9UF3mzgNQtxLVCC26EyPqtQBJ58j6DBHebaJEOh6YVXx
PJ2iF5bmbfJWXe6I0N0u6P0651UOzakeGi6iGccbv4USuBGgdWK0Bf1YPjNMPDPT
BTegtzX3pJb6fTMKhfLitkHR4eMCgYEA7gYi1CXPtbPXuGpiaj9BW5Hgs/eth9e8
HjQ3qfj8auQz0jPAsS31h4evj86SARyCRxNeOGiVH7MqLx2ZTdiXyf6VqUQLO7mA
t3lV7JC0VOrppQNm4K5848gGmrrazeqrpRNTaWgHlVuOZcZaIMzO13J3dRZWRaRh
2/zwH3anMTMCgYBMC7PuLqiqkpds15jW83GksR/I9BI2BGDIha4qK6R0gs+uluHR
Af9EwZoomyXNoGStXlFgAgfb1YlqeIUfZ7zRuFqSUIYILm6jVXZ+SdItfQULR7KZ
tt7KRjEQFpv8RhPcIuCqLIp/4qtfDUiBD6cROA+CiJsNpXH8/W9mkRtjzwKBgAVC
TXKygyxYlOOWNiZyz1bemkBfsI3Xzmg8bx5qSelysVJrok5H3azo6pAa2E79+kLn
wqUsal8Q7lWsKb72kiP8ZAIhZr4jExz6qVNYvyNBLXhf4t4D/O5rdPnmNv9lt/Ul
wCoMCl7abwMApu0imU9ZUBpeK/nN7/uUUxne3ULRAoGAfFC9+zunG65W3hmZ5F2R
XSM9Iqx/aekIsFBIsdzFv5n32m/z0Qwjji2ajc0+5zBA6WzquAp00EMWyzMN0rtB
wfregVGP+kggaiDis0Xa64qyXgCPktz99eIn6sZxJwB7Bz/lYNTXLhd7DYZn1y2w
SrzfyOOhBWKOyeRWsgcDutg=
-----END PRIVATE KEY-----

'''

# content of file remotestash-cert-signed.pem
cert_remotestash_cert = '''-----BEGIN CERTIFICATE-----
MIIDCjCCAfICCQCYTjHvfdmGITANBgkqhkiG9w0BAQsFADBGMQswCQYDVQQGEwJV
UzEWMBQGA1UECgwNUmVtb3RlU3Rhc2hDQTELMAkGA1UECwwCQ0ExEjAQBgNVBAMM
CWF1dGhvcml0eTAeFw0yMTAyMTMxMDUzMjdaFw0zMTAyMTExMDUzMjdaMEgxCzAJ
BgNVBAYTAlVTMRQwEgYDVQQKDAtSZW1vdGVTdGFzaDEPMA0GA1UECwwGc2VydmVy
MRIwEAYDVQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK
AoIBAQDhThz9C8oU30YU1LTo37NLVUWVFG+W+DiEfFLChMDnTYjjcw2Z3ncUwAjD
AEQ8ljc0t5Qh2IjdBFr4ROQWH/fXue4MLGmq+cdxD/RITXX6LWUbVz/c1yXaxjGL
SL/FZzpDpKzmv+geHVCi+di/8W1ZbFbwLhj5o/FxXoIU0iD76Q3l7ymeSszEs/XT
bNWHOhGmMf+fwvqBK2ehuw3IHtAlK+apJvUaKlBKmSiHrhbQyH0VaM0zKTi8pFDV
3yA+1aEPUOZkXC4qu30X0j/ZP+j/UvNMyALX8RLaG55EB0NgCk/Cj2Zft8VdupP3
ot/ZlTtrC41Lj2gwT1ym5W5GIXM5AgMBAAEwDQYJKoZIhvcNAQELBQADggEBAKVz
AC24kwtwiixKOrb6Kp9Jk4fUIV7LOKn5YXa4Gr4oO57kq79cYQ9DTB7NC354mVF2
DVrmggLA/ST909aPlk+2kM8jSEKIbqNF9bMaPiygCD9+BnJFAsdUmiTpJvd68cQI
pEbtdVZ3cdUsJubUJ6eNEzOrBUYgW4DHjbLq22QmjXdkNcxFZEgeIatNu07+yu1P
nxLaHcnlRYYd+RfYTYMxK1ymAyvN4DR04kwgsBNG+HdRibbVkgzk5oFsYUScJ4aQ
gK1RbbZTLW3mqhwuC393ysqDjZvcOmr6gb7D5SqXIPBpALfvkVoo2Slxz7m+Ai0o
OQ5YocjfiO5vdo9PknU=
-----END CERTIFICATE-----
'''

def ensure_remote_stash_dir(location = '~/.remotestash'):
    '''
    ensure storage directory and certicates exists
    return tuple with the location and asset location to use
    '''
    location_dir = os.path.expanduser(location)
    location_asset_dir = os.path.join( location_dir, 'assets' )
    if not os.path.isdir( location_asset_dir ):
        os.makedirs( location_asset_dir )

    cert_file = os.path.join( location_dir, 'remotestash-cert.pem' )
    if not os.path.isfile( cert_file ):
        with open( cert_file, 'w' ) as cf:
            cf.write( cert_remotestash_cert )

    key_file = os.path.join( location_dir, 'remotestash-key.pem' )
    if not os.path.isfile( key_file ):
        with open( key_file, 'w') as kf:
            kf.write( cert_remotestash_key )
            
    return (location_dir, location_asset_dir)

class RemoteStashItem:
    '''
    this class represent information about an item in the stash
    it contains functionality to load from file or other types, ability to output/save/format itself

    it will maintain the data either in text as str or data as bytes
    '''
    def __init__(self,info):
        '''
        info should be a dictionary of meta data. All keys will
        be kept in lower case. 

        Expected keys are:
           content-type: mime-type of the content of the item
           filename: filename for the item if applicable, without path

        '''
        self.info = { k.lower(): v for (k,v) in info.items() }
        self.data = None
        self.text = None

    def __repr__(self):
        return f'RemoteStashItem({self.info})'


    def info_from_headers(headers):
        info = {}
        # Replace functionality of deprecated cgi.parse_header()
        msg = EmailMessage()
        if 'content-type' in headers:
            msg['content-type'] = headers['content-type']
            ctype, charset = msg.get_content_type(), msg.get_content_charset(failobj=None)
        else:
            ctype, charset = 'application/octet-stream', {}
        
        info['content-type'] = ctype
        info['encoding'] = None
        if charset:
            info['encoding'] = charset
        elif ctype.startswith( 'text/' ):
            info['encoding'] = 'utf-8'
        
        if 'content-disposition' in headers:
            msg['content-disposition'] = headers['content-disposition']
            cdisp, filename = msg.get_content_disposition(), msg.get_filename(failobj=None)
            info['content-disposition'] = cdisp
            if filename:
                info['filename'] = filename

        return info
    
    def from_file(info,infile):
        '''
        load itself from the data of a file object
        info should contains 'content-type' and 'file' with the name
        '''
        rv = None
        rv = RemoteStashItem(info)
        rv.data = infile.read()
        # If we read a string, (file open without 'b' mode), save in text
        if isinstance( rv.data,str ):
            rv.text = rv.data
            rv.data = None
            
        return rv

    def from_json(jsondata):
        if isinstance( jsondata, bytes):
            return RemoteStashItem.from_data( jsondata, { 'content-type':'application/json' }  )
        else:
            return RemoteStashItem.from_data( jsondata.encode( 'utf-8'), { 'content-type':'application/json', 'encoding':'utf-8' }  )
    
    def from_data(data,info):
        rv = RemoteStashItem(info)
        rv.data = data
        
        return rv

    def from_string(text,info):
        rv = RemoteStashItem(info)
        rv.text = text
        
        return rv

    def validate_info(self):
        if 'content-type' not in self.info:
            print( 'Missing Content Type' )

    def encoding(self):
        '''
        determine (or guess) the encoding. Will try to parse content-type or
        if strict is False, will guess based on the type of the data 
        '''
        if 'encoding' in self.info:
            return self.info['encoding']
        return None

    def content_type(self):
        return self.info['content-type']

    def filename(self):
        '''
        if filename was linked to the data return it, otherwise None (for text for ex)
        '''
        if 'filename' in self.info:
            return self.info['filename']
        else:
            return None
        
    def json_dict(self):
        return self.info

    def from_asset(info,location):
        '''
        info should contains 'Content-Type' and 'assetname'
        '''
        rv = None
        if location and 'assetname' in info:
            filename = os.path.join( location, info['assetname'] )
            if os.path.isfile( filename ):
                with open(filename, 'rb') as readf:
                    rv = RemoteStashItem.from_file( info, readf )
                    
        if not rv:
            rv = RemoteStashItem(info)
            
        return rv

    def save_asset(self,location):
        data = self.as_data()
        if data:
            assetname = hashlib.sha1(data).hexdigest()
            path = assetname
            path = os.path.join( location, path )
            self.info[ 'assetname'] =  assetname
            with open( path, 'wb' ) as of:
                of.write( self.data )

    def clear_asset(self,location):
        if 'assetname' in self.info:
            path = self.info['assetname']
            if location:
                path = os.path.join( location, path )
            if os.path.isfile(path ):
                os.remove( path )
            
    def as_str(self):
        if self.text:
            return self.text

        if self.data:
            encoding = self.encoding()
            if encoding:
                return self.data.decode( encoding )

        return None

    def as_data(self):
        if self.data:
            return self.data
        
        if self.text:
            encoding = self.encoding()
            if encoding:
                return self.text.encode( encoding )

        return None
    
    def output(self,outfile=sys.stdout):
        if not self.data and not self.text:
            return
        
        if 'b' in outfile.mode:
            data = self.as_data()
            outfile.write( data )
        else:
            data = self.as_str()
            if data:
                outfile.write( data )
            else:
                data = self.as_data()
                t = self.info['content-type']
                outfile.write( f'{len(data)} bytes of type {t}' )

class RemoteStashLocal:
    '''
    this class implements a locally saved stash of RemoteStashItem
    The stash will be saved by default in ~/.remotestah
    The information of the content of the stash will be saved as contents.json
    will support pull,push,last,status operations
    '''
    def eprint(self, *args, **kwargs):
        if self.verbose > 3:
            # print(self, *args, file=sys.stderr, **kwargs)
            print(f'{self.__class__.__name__}', *args, file=sys.stderr, **kwargs)
        else:
            print(*args, file=sys.stderr, **kwargs)
    
    def __init__(self,args):
        self.args = args
        if 'verbose' in args:
            self.verbose = args.verbose
        else:
            self.verbose = False
        
        if 'dir' in self.args:
            self.location = self.args['dir']
        else:
            self.location = os.path.expanduser("~/.remotestash")

        (self.location, self.location_assets) = ensure_remote_stash_dir(self.location)

        self.content_file = os.path.join( self.location, 'contents.json' )
        if os.path.isfile( self.content_file ):
            with open( self.content_file ) as jf:
                self.contents = json.load( jf )
        else:
            self.contents = {'items':[]}

        if self.verbose:
            size = len(self.contents['items'])
            print( f'Local Stash {self.location} {size} items' )

    def pull(self):
        '''
        pull an item from a local stash, will return it and delete from the stash
        return None if no more items
        '''
        if len(self.contents['items']):
            info = self.contents['items'].pop()
            item = RemoteStashItem.from_asset(info,self.location_assets)
            self.clear_asset(item)
            self.save_content()
            if self.verbose:
                size = len(self.contents['items'])
                print( f'Local Stash pull {item} [{size} items]' )
            
            return item
        else:
            if self.verbose:
                print( 'Local Stash empty no item to pull' )

        return None

    def list(self):
        '''
        List the content of the local stash
        '''
        pprint( self.contents )

    def clear_asset(self,item):
        '''
        remove asset for the item, will check if asset not used by another item
        before removing
        '''
        assetname = item.info['assetname'] if 'assetname' in item.info else ''
        remove=True
        # don't remove if asset used by another item
        for other in self.contents['items'][:-1]:
            if 'assetname' in other and other['assetname'] == assetname:
                if self.verbose:
                    print( f'keep asset for {item}' )
                remove=False

        if remove:
            item.clear_asset(self.location_assets)
        
    def clear(self):
        '''
        empty the local stash of all items and assets
        '''
        for c in self.contents['items']:
            item = RemoteStashItem.from_asset(c,self.location_assets)
            self.clear_asset(item)
        if self.verbose:
            size = len(self.contents['items'])
            print( f'Cleared {size}' )
        self.contents['items'] = []
        self.save_content()

    def clean(self):
        '''
        remove any asset that are not associated with an item in the local stash
        '''
        assets = os.listdir(self.location_assets)
        for assetname in assets:
            found = False
            for c in self.contents['items']:
                if c['assetname'] == assetname:
                    found = True

            if not found:
                print( f'{assetname} not found' )
            else:
                print( f'{assetname} found' )
    
    def status(self):
        '''
        status from the local stash
        '''
        total = len( self.contents['items'] )
        rv = {'items-count':total}
        
        if total > 0:
            item = RemoteStashItem.from_asset(self.contents['items'][-1],self.location_assets)
            if self.verbose:
                print( item.info )
            if item.as_data():
                rv['last'] = {'size': len(item.as_data()), 'content-type':item.info['content-type'] }
            else:
                rv['last'] = {'size': 0, 'content-type':item.info['content-type'] }
        else:                
            rv['last'] = {'size': 0, 'content-type':'empty' }
        return rv
            
    def last(self):
        '''
        last from the local stash
        '''
        if len(self.contents['items']):
            item = RemoteStashItem.from_asset(self.contents['items'][-1],self.location_assets)
            return item

        return None

    def push(self,item):
        '''
        push item to the local stash
        '''
        item.save_asset(self.location_assets)

        if len(self.contents['items']) and (
            # If the item to be added doesn't have an assetname, server
            # responded with a 500 error.
            # Likely: MultipartError('Unexpected end of multipart stream.')
            not hasattr(item.info, 'keys') or ('assetname' not in item.info.keys())
            or
                (
                    # Check if the key exists first, else it throws KeyError!
                    hasattr(self.contents['items'][-1], 'keys') and 'assetname' in self.contents['items'][-1].keys()
                and
                    self.contents['items'][-1]['assetname'] == item.info['assetname']
                )
            ):
            if self.verbose > 0:
                print( f'Skipping adding duplicate of last {item}' )
            return
        
        self.contents['items'].append( item.json_dict() )
        
        if self.verbose:
            size = len(self.contents['items'])
            print( f'Local Stash pushed {item} [{size} items]' )
        self.save_content()

    def __eq__(self,other):
        print( f'checking {self} and {other}' )

        if 'assetname' in self.info and 'assetname' in other.info:
            return self.info['assetname'] == other.info['assetname']

        return False
        
    def save_content(self):
        with open( self.content_file, 'w' ) as jf:
            json.dump( self.contents, jf )

class RemoteStashClient:
    '''
    class to run a zeroconf listener to find a remotestash server to execute a specific action
    when there service is found the method 'cmd' will be executed
    args will be checked for:
       name: filter on service with that name only
       verbose: add output as service are found
    '''
    def __init__(self,cmd,stash):
        self.cmd = cmd
        self.stash = stash
        self.args = stash.args
        if self.args.verbose > 0:
            self.verbose = True
        else:
            self.verbose = False
            
    def remove_service(self, zeroconf, type, name):
        if self.verbose:
            print( f'Service {name} removed' )

    def update_service(self, zeroconf, type, name):
        if self.verbose:
            print( f'Service {name} updated' )
        
    def add_service(self, zeroconf, type, name):
        '''
        Called when a service is found
        Will call the command to run on the service
        unless a name was specified and does not match
        '''
        if not self.args.name or self.args.name in name:
            info = zeroconf.get_service_info(type, name)
            self.ip = socket.inet_ntoa(info.addresses[0])
            self.port = info.port
            self.info = info
            self.properties = {}
            for (k,v) in info.properties.items():
                self.properties[k.decode('utf-8')] = v.decode('utf-8')
            if self.verbose:
                print( f'Found Service {info.name} added, running {self.cmd} on {self.ip}:{self.port} {self.properties}')
            getattr(self,self.cmd)()
        else:
            if self.verbose:
                info = zeroconf.get_service_info(type, name)
                self.ip = socket.inet_ntoa(info.addresses[0])
                self.port = info.port
                self.info = info
                print( f'Skipping Service {name} on {self.ip}:{self.port}')
            
    def item_from_response(self,response):
        '''
        build the item from the http response from the server on the remote stash
        '''
        info = RemoteStashItem.info_from_headers(response.headers)
        return RemoteStashItem.from_data( response.content, info )

    def get(self,path):
        '''
        execute a get request on the server of the found service
        '''
        self.session = Session()
        ip = self.ip
        port = self.port
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        url = f'https://{ip}:{port}/{path}'
        if self.verbose:
            print( f'starting GET {url}' )
        response = self.session.get( url, verify=False )
        return response
    
    def post(self,path,data):
        '''
        execute a post request on the server of the found service
        '''
        self.session = Session()
        ip = self.ip
        port = self.port
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        url = f'https://{ip}:{port}/{path}'
        headers = {}
        if self.filename:
            if self.verbose:
                print( 'starting POST {} file {} {}'.format(url,self.filename,self.content_type) )
            files = {'file':(self.filename, data, self.content_type) } 
            response = self.session.post( url, verify=False, files = files, headers = headers )
        else:
            if self.content_type:
                headers[ 'Content-Type'] =  self.content_type
            if self.verbose:
                print( 'starting POST {}  data {}'.format(url,self.filename,) )
            response = self.session.post( url, verify=False, data = data, headers = headers )
        return response

    def list(self):
        '''
        list all the available server found
        '''
        name = self.info.name
        if name.endswith( '._remotestash._tcp.local.' ):
            name = name[:len('._remotestash._tcp.local.')]
        print( f'Found "{name}" from {self.info.server} on {self.ip}:{self.port}')
        # don't exit to find more services
    
    def push(self):
        '''
        execute a push to the server on the service found
        '''
        response = self.post('push',self.content)
        print( response.content )
        self.exit()

    def pull(self):
        '''
        execute a pull to the server on the service found
        '''
        response = self.get('pull')
        item = self.item_from_response( response )
        if item:
            self.outfile = self.stash.get_output_file(item)
            item.output(self.outfile)
        self.exit()

    def last(self):
        '''
        execute a last to the server on the service found
        '''
        response = self.get('last')
        # if binary use response.content
        item = self.item_from_response( response )
        if item:
            self.outfile = self.stash.get_output_file(item)
            item.output(self.outfile)
        self.exit()
        
    def status(self):
        '''
        execute a status to the server on the service found
        '''
        response = self.get('status')
        item = self.item_from_response( response )
        self.outfile = self.stash.get_output_file(item)
        item.output(self.outfile)
        self.exit()

    def exit(self):
        '''
        exit from all thread and ensure all output is flush  
        '''
        sys.stdout.flush()
        if self.outfile:
            self.outfile.flush()
        os._exit(0)
        
class RemoteStashServerAdvertiser:
    '''
    This class advertise the server using zeroconf
    '''
    def __init__(self,port=None):
        self.ip = self.get_ip()
        self.port = port if port else self.get_port() 
        
    def get_ip(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            # doesn't even have to be reachable
            s.connect(('10.255.255.255', 1))
            IP = s.getsockname()[0]
        except:
            IP = '127.0.0.1'
        finally:
            s.close()
        return IP

    def get_name(self):
        aa = pwd.getpwuid( os.getuid() )
        # could use pw_gecos
        return aa.pw_name
    
    def get_port(self):
        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
            s.bind(('', 0))
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            return s.getsockname()[1]
    
    def start_advertisement(self,name):
        self.info = ServiceInfo(
            "_remotestash._tcp.local.",
            "{}._remotestash._tcp.local.".format(name),
            addresses=[socket.inet_aton(self.ip)],
            port=self.port,
            server=socket.gethostname() + '.local.',
            properties={"temporary":"no", "uuid":str(uuid.uuid4())},
        )

        zeroconf = Zeroconf()
        zeroconf.register_service(self.info)

    def clean_advertisement(self):
        zeroconf = Zeroconf()
        zeroconf.unregister_service(self.info)
        zeroconf.close() 

# Simple re-implementation of the http.server.HTTPServer base class
class RemoteStashSocketServer(socketserver.TCPServer):

    allow_reuse_address = 1    # Seems to make sense in testing environment

    def __init__(self, server_address, RequestHandlerClass, stash):
        """Constructor.  May be extended, do not override."""
        self.server_address = server_address
        self.RequestHandlerClass = RequestHandlerClass
        self.stash = stash
        self.server_name = None
        # Call the base class TCPServer constructor method
        super().__init__(server_address, RequestHandlerClass)

    def server_bind(self):
        """Override server_bind to store the server name."""
        socketserver.TCPServer.server_bind(self)
        host, port = self.server_address[:2]
        self.server_name = socket.getfqdn(host)
        self.server_port = port

    # Override the finish_request method to implement custom request handler args
    def finish_request(self, request, client_address):
        """
        Finish one request by instantiating RequestHandlerClass.
        Pass in our custom arg: stash
        """
        self.RequestHandlerClass(request, client_address, self, stash=self.stash)
    
class RemoteStashServer(RemoteStashSocketServer):
    '''
    Implement an https server that can use our custom instance variables
    '''
    def eprint(self, *args, **kwargs):
        """A print function to print directly to stderr."""
        print(*args, file=sys.stderr, **kwargs)

    def __init__(self, server_address, stash):
        """Constructor for RemoteStashServer."""
        self.RequestHandlerClass = RemoteStashServerRequestHandler
        self.stash = stash
        if self.stash.verbose > 3:
            self.eprint(f'{self.__class__.__name__}.__init__({self}, {server_address}, {stash})')
            self.eprint(f'Calling: {super().__class__.__name__}.__init__({server_address}, {self.RequestHandlerClass}, {stash})')
        super().__init__(server_address, self.RequestHandlerClass, stash)

class RemoteStashServerRequestHandler(BaseHTTPRequestHandler):
    '''
    Implement an https server that will process the remotestash protocol using a local stash
    '''
    # Memory Limit only applies verbatim if Content-Type is "application/x-www-form-urlencoded" (RFC 7578 § 5.3), or "application/x-url-encoded" (RFC 2388 § 5.6)
    # Otherwise, for "multipart/form-data" the limit is the minimum of:
    # disk_limit (default: 2^30), and mem_limit (default: 2^20)
    # The entire request is read into memory if Content-Length is not sent.
    # Note: "application/x-url-encoded" was a typo in RFC 2388, subsequent
    # errata corrected it to "application/x-www-form-urlencoded", but python
    # multipart module still supports it.
    # References:
    #   - https://www.rfc-editor.org/rfc/inline-errata/rfc2388.html
    #   - https://www.rfc-editor.org/errata_search.php?rfc=2388&rec_status=0&errata_type=1
    #   - https://www.rfc-editor.org/rfc/inline-errata/rfc7578.html
    DEFAULT_CONTENT_LENGTH_MEM_LIMIT = 2**20 # 1 MiB (default 'mem_limit' inside parse_form_data())
    DEFAULT_CONTENT_LENGTH_DISK_LIMIT = 2**30 # 1 GiB (default 'disk_limit' inside MultipartParser)
    DEFAULT_ERROR_MESSAGE_FORMAT = "" # Empty to avoid python bytes string (b"") in the response
    DEFAULT_ERROR_CONTENT_TYPE = "application/json;charset=utf-8"
    DEFAULT_ERROR_JSON_FORMAT = """{"code": %(code)d, "message": %(message)s, "explanation": %(explain)s}"""
    DEFAULT_OK_CONTENT_TYPE = "application/json;charset=utf-8"
    # TODO: Should we implement this for success responses as well? If so, we
    # should add a 'success' key to the response and/or modify the iOS app to
    # work with this.
    DEFAULT_OK_JSON_FORMAT = """{"code": %(code)d, "message": %(message)s, "explanation": %(explain)s}"""


    HTTP_STATUS_DESCRIPTIONS = { v: v.description for v in http.HTTPStatus.__members__.values() }
    # Example of how to see all possible HTTPStatus descriptions:
    #  print(f'{[ HTTPStatus.__members__[thing].description for thing in things ] }

    ALLOWED_METHODS = ["GET", "POST", "COFFEE", "TEA"]

    def eprint(self, *args, **kwargs):
        """
        A print function to print directly to stderr.

        Bypasses the machinery of the log_message() method, which replaces
        Unicode control characters with escaped hex before writing the output to
        stderr.

        This allows us to print the traceback of an exception to stderr without
        string mangling and newlines included.
        """
        if self.verbose > 3:
            print(self, *args, file=sys.stderr, **kwargs)
        else:
            print(*args, file=sys.stderr, **kwargs)

    def sanitize_data(self, data):
        """
        Sanitize data for printing to stderr.

        Replace any Unicode control characters with escaped hex.
        """
        if self.verbose > 4:
            self.eprint( f'sanitize_data() - type(data): {type(data)}' )
        match type(data):
            case builtins.bytes:
                return ''.join(
                    c for c in data.decode('utf-8', 'backslashreplace')
                )
            case builtins.str:
                return ''.join(
                    c if c.isprintable() else fr'\x{ord(c):02x}'
                    for c in data
                )
            case builtins.int:
                return str(int(data))
            case builtins.dict:
                return {self.sanitize_data(k): self.sanitize_data(v) for k, v in data.items()}
            case _:
                if hasattr(data, '__str__'):
                    return str(data)
                elif hasattr(data, '__repr__'):
                    return repr(data)
                else:
                    return ''

    def __init__(self, *args, stash):
        self.server_version = "RemoteStashServer/" + __version__
        self.protocol_version = "HTTP/1.1" # Default to HTTP/1.1 for Expect: 100-continue support
        self.error_message_format = self.DEFAULT_ERROR_MESSAGE_FORMAT
        self.error_content_type = self.DEFAULT_ERROR_CONTENT_TYPE
        self.timeout = 60 # Default to 1 minute for handle_request timeout
        # Pull our verbosity level and args from RemoteStash object
        self.verbose = stash.verbose
        self.args = stash.args
        if self.verbose > 3:
            self.eprint( f'{self.__class__.__name__}__init__({self}, {args}, {stash})' )
            # self.eprint( f'self.__dir__() = {self.__dir__()}' )
            # self.eprint( f'__init__(self, {args})' )
            # self.eprint( f'stash.__dir__() = {stash.__dir__()}' )
        # Initialize to None
        self.body = None
        self.content_type = None
        self.content_length = None
        self.filename = None
        # Call the base class BaseHTTPRequestHandler constructor method
        # Don't pass our custom stash arg now that we've stored what we wanted
        # in self
        super().__init__(*args)

    def push(self):
        if self.body is None:
            pass

        stash = RemoteStashLocal({})
        if self.verbose > 0:
            stash.verbose = True
        info = { 'content-type': self.content_type }
        if self.filename:
            info['filename'] = self.filename
        item = RemoteStashItem.from_data( self.body, info )
        try:
            stash.push( item )
        except NotImplementedError as e:
            if self.verbose > 1:
                self.log_error('%s: %s', type(e).__name__, str(e))
                self.eprint( f'Error: \n{traceback.format_exc()}' )
            raise
        except Exception as e:
            if self.verbose > 1:
                self.log_error('%s: %s', type(e).__name__, str(e))
                self.eprint( f'Error: \n{traceback.format_exc()}' )
            self.respond( 500, {}, f'{type(e).__name__}: {str(e)}', log_message=f'Error: {str(type(e).__name__)}: {str(e)} ocurred.\n{traceback.format_exc()}' )
            return
        self.respond( 200, { 'content-type' : 'application/json; charset=utf-8' }, json.dumps({'success':1}), log_message=f'Received: {item}' )

    def pull(self):
        stash = RemoteStashLocal({})
        stash.verbose = True
        item = stash.pull()
        self.respond_item( item )
        
    def last(self):
        stash = RemoteStashLocal({})
        stash.verbose = True
        item = stash.last()
        self.respond_item( item )

    def status(self):
        stash = RemoteStashLocal({})
        stash.verbose = True
        val = stash.status()
        rv = RemoteStashItem.from_json( json.dumps(val) )
        self.respond_item( rv )

    # Unsupported REST API methods: respond with 405 Method Not Allowed
    # If we do not define these methods, the BaseHTTPRequestHandler will respond
    # 501 "Unsupported Method ('FOO')" (Really: 501 Not Implemented)
    # It also will not respond with any JSON or body content.
    # However, it does not accurately describe the fact that we recognize these
    # but explicitly don't allow them. We also want to respond with a JSON body
    # with slightly more helpful information.
    # Define each of these via meta-programming to avoid repetition
    for method in ['HEAD', 'DELETE', 'PUT', 'OPTIONS', 'TRACE', 'CONNECT', 'PATCH']:
        locals()[f'do_{method}'] = lambda self: (
            allowed_msg := ', '.join(self.ALLOWED_METHODS) ,
            self.respond(405, {'Allow': allowed_msg}, self.sanitize_data(self.command[:10]) if self.command else '', log_message=f'{self.HTTP_STATUS_DESCRIPTIONS[405]}. Did you mean: {allowed_msg}')
        )

    # Supported HTTP REST API Methods
    def do_COFFEE(self):
        self.do_TEA()

    def do_TEA(self):
        self.respond( 418, {}, '🫖', log_message=self.HTTP_STATUS_DESCRIPTIONS[418] )

    def do_POST(self):
        self.do_GET()

    def do_GET(self):
        try:
            self.breakdown_request()
        except NotImplementedError as e:
            self.eprint('Encountered a NotImplementedError when handling request. This is normal for some unsupported or unknown requests.')
            self.eprint(f'Error: {e}')
            self.eprint(f'Error: \n{traceback.format_exc()}')
            self.close_connection = True
            return
        except TimeoutError as e:
            self.eprint('Encountered a TimeoutError when handling request. This was probably due to the client taking too long to send the request, not sending Content-Type, and/or never sending the final multipart/form-data boundary delimiter.')
            self.eprint(f'Error: {e}')
            self.eprint(f'Error: \n{traceback.format_exc()}')
            self.close_connection = True
            return
        except MultipartError as e:
            self.eprint('Encountered a MultipartError when handling request. This was probably due to the client sending something unexpected.')
            self.eprint(f'Error: {e}')
            self.eprint(f'Error: \n{traceback.format_exc()}')
            self.close_connection = True
            return
        except Exception as e:
            self.eprint(f'Error: {e}')
            self.eprint(f'Error: \n{traceback.format_exc()}')
            self.close_connection = True
            return

        hasResponse = False
        try:
            supported_paths = ['push', 'pull', 'last', 'status']
            for method in supported_paths:
                if self.parsed_path.path.startswith( f'/{method}' ):
                    if self.verbose > 2:
                        self.eprint(f'Calling {method}()')
                    getattr(self, method)()
                    break
            else: # Respond 400 to unknown API paths: Bad Request
                allowed_msg = ', '.join('/' + m for m in supported_paths)
                self.respond( 400, {'Allowed': allowed_msg}, f'Unknown API path: {self.parsed_path.path}', log_message=f'Bad API path in request. Did you mean: {allowed_msg}' )
                hasResponse = True
        except Exception as e:
            # Something wrong on our end
            self.eprint(f'Error: {e}')
            self.eprint(f'Error: \n{traceback.format_exc()}')
            if not hasResponse: # If error happened during self.reponse call, don't respond again
                self.respond( 500, {}, 'Internal Server Error', log_message=f'Error: {str(type(e).__name__)}: {str(e)} ocurred.\n{traceback.format_exc()}' )

    def breakdown_request(self):
        self.parsed_path = parse.urlparse(self.path)
        self.query_dict = parse.parse_qs(self.parsed_path.query)

        self.headers_dict = {}
        for (k,v) in self.headers.items():
            self.headers_dict[ k.lower() ] = v
        self.filename = None

        # Replace functionality of deprecated cgi.parse_header()
        msg = EmailMessage()
        if self.verbose > 1:
            self.log_message('breakdown_request(): Handling request')
        if self.verbose > 2:
            self.log_message('Headers: %s', self.sanitize_data(self.headers))

        if 'Expect' in self.headers:
            if self.verbose > 1:
                self.eprint(f'Client sent: Expect: {self.sanitize_data(self.headers["expect"])}')
            if self.headers['expect'].lower() == '100-continue':
                # BaseHTTPRequestHandler.parse_request() Handles 100 Continue
                # for HTTP >= 1.1 See: IETF RFC 7231 § 5.1.1 (obsolete) and updated RFC 9110 § 10.1.1
                self.eprint(f'self.protocol_version: {self.protocol_version}')
                # We would have to do this if we kept server protocol_version at HTTP/1.0
                # self.handle_expect_100()
                # self.respond(100, {'Continue': 'HTTP/1.1 100 Continue'})
                # self.end_headers()
            else:
                # Respond 417 to unknown Expect: values according to IETF RFC 9110 § 10.1.1
                self.respond(417, {}, 'Expectation Failed', log_message=f'Expectation Failed: {self.sanitize_data(self.headers["expect"])}')
                raise NotImplementedError(f'Unsupported "Expect:" header value: {self.sanitize_data(self.headers["expect"])}')
        if 'Content-Type' in self.headers:
            if self.verbose > 1:
                self.log_message('Content-Type: %s', self.sanitize_data(self.headers["content-type"][:100]))
            msg['content-type'] = self.headers['content-type']
            ctype, pdict = msg.get_content_type(), msg['content-type'].params
            if self.verbose > 2:
                self.log_message('pdict: %s', self.sanitize_data(pdict))
        else:
            ctype = 'application/octet-stream'

        if 'content-disposition' in self.headers:
            if self.verbose > 2:
                self.log_message('Content-Disposition: %s', self.sanitize_data(self.headers["content-disposition"]))
            msg['content-disposition'] = self.sanitize_data(self.headers['content-disposition'][:100])
            cdisp, filename = msg.get_content_disposition(), msg.get_filename(failobj=None)
            if self.verbose > 2:
                self.log_message('cdisp: %s, filename: %s', self.sanitize_data(cdisp[:100]), self.sanitize_data(filename[:100]))
            self.info['content-disposition'] = self.sanitize_data(cdisp[:100])
            if filename:
                self.filename = self.sanitize_data(filename[:100])
            
        if ctype == 'multipart/form-data':
            if self.verbose > 2:
                self.log_message('ctype: %s', self.sanitize_data(ctype[:100]))
                self.log_message('pdict: %s', self.sanitize_data(pdict))
                self.log_message('rfile: %s', self.rfile) if self.rfile else self.log_message('rfile: None')
            # boundary_bytes = bytes(pdict['boundary'], 'utf-8') ## Now handled by multipart.parse_form_data()
            if 'Content-Length' in self.headers and self.headers['Content-Length']:
                content_length_int = int(self.headers['Content-Length'])
            else:
                content_length_int = -1
                self.eprint(f'Request missing Content-Length: {self.sanitize_data([k[:100] for k in self.headers.keys()])}')
                if self.verbose > 2:
                    # Note: Reproduce this case by sending a POST request without Content-Length, and sending an actively growing log file to the server
                    #  host_addr=$(remotestash  list  | grep '\.local\. on' | sed -r -e 's/.*\.local\.? on (([0-9]{1,3}\.){3}[0-9]{1,3}):([0-9]+)/\1:\3/');
                    #  log_file=/var/log/something.log;
                    #  curl -k -F "file=@${log_file};filename=$(basename ${log_file})" "https://${host_addr}/push" -o -  -XPOST -H "Content-Length:" -v
                    self.eprint('multipart.parse_form_data() will read until EOF or timeout.  This could allow for DoS attacks if client never stops sending data and timeout is long.')

            if self.verbose > 1:
                self.eprint( f'Content-Length from self.headers: {content_length_int}')
            # Replace functionality of deprecated cgi.FieldStorage() with multipart.parse_form_data()
            err_headers = None
            try:
                strict_mode = True
                mem_limit = self.DEFAULT_CONTENT_LENGTH_MEM_LIMIT
                disk_limit = self.DEFAULT_CONTENT_LENGTH_DISK_LIMIT
                if self.verbose > 2:
                    self.eprint(f'breakdown_request(): Memory limit for parse_form_data(): {mem_limit}')
                    self.eprint(f'breakdown_request(): Disk limit for parse_form_data(): {disk_limit}')
                    self.eprint(f'breakdown_request(): Request handler timeout for socketserver.BaseServer: {self.timeout}')
                (forms, files) = parse_form_data({'REQUEST_METHOD': self.command if self.command else 'POST', 'CONTENT_TYPE': self.headers['content-type'],
                                                  'wsgi.input': self.rfile, 'CONTENT_LENGTH': content_length_int },
                                                  charset="utf8", strict=strict_mode, mem_limit=mem_limit, disk_limit=disk_limit)
            except TimeoutError as e:
                self.log_error(f'Error: {e}')
                self.respond( 408, err_headers if err_headers else {}, str(type(e).__name__), log_message=f'Error: {e}')
                raise
            except MultipartError as e:
                match e.args[0]:
                    case 'Boundary does not fit into buffer_size.':
                        response_code = 500
                    case 'Memory limit reached.':
                        response_code = 500
                    case 'Disk limit reached.':
                        if self.verbose > 3:
                            # If we are in verbose mode, send the real cause of the error to client
                            response_code = 507 # Insufficient Storage
                        else:
                            # We may not trust the client, send generic 500 error
                            response_code = 500 # Internal Server Error
                    case 'Request too big. Increase MAXMEM.':
                        response_code = 413 # Request Entity Too Large
                    case 'Unsupported content type.':
                        response_code = 415 # Unsupported Media Type
                    case 'Request method other than POST or PUT.':
                        response_code = 405 # Method Not Allowed
                        err_headers = {'Allow': ', '.join(self.ALLOWED_METHODS)}
                    case 'Unexpected end of multipart stream.':
                        response_code = 400 # Bad Request
                    case _:
                        # All other MultiPartError types are due to bad client requests
                        response_code = 400
                self.log_error(f'Error: {e}')
                self.respond( response_code, err_headers if err_headers else {}, str(type(e).__name__), log_message=f'Error: {e}')
                raise
            except Exception as e:
                self.log_error(f'Error: {e}')
                self.respond( 500, {}, str(type(e).__name__), log_message=f'Error: {e}' )
                raise
            if len(files) > 0:
                # Only handle the first file found
                if self.verbose > 1:
                    self.eprint( f'Found {len(files)} files' )
                for k in files.keys():
                    if self.verbose > 2:
                        self.eprint( f'Found file key: {self.sanitize_data(k)}' )
                        self.eprint( f'Found file: {self.sanitize_data(files[k])}')
                        self.eprint( f'Found filename: {self.sanitize_data(files[k].filename[:100])}')
                        self.eprint( f'size: {self.sanitize_data(files[k].size)}')
                        self.eprint( f'Content-Type: {self.sanitize_data(files[k].content_type[:100])}')
                        self.eprint( f'Charset: {self.sanitize_data(files[k].charset[:100])}')
                        self.eprint( f'Content-Length: {self.sanitize_data(files[k].content_length)}')
                        self.eprint( f'Content-Disposition: {self.sanitize_data(files[k].disposition[:100])}')
                        if self.verbose > 3:
                            self.eprint( f'raw data (1st 100 bytes): {self.sanitize_data(files[k].raw[:100]) + " ..."}')
                    filename = files[k].filename
                    record = files[k] # MultipartPart
                if self.verbose > 1:
                    self.eprint( f"files.keys()['file']: {self.sanitize_data(files['file'])}" )
                # filename = files.keys()[0]
                # record = files[filename]
                self.filename = self.sanitize_data(filename[:100])
                self.body = record.raw
                self.content_length = len(self.body)
                self.content_type = self.sanitize_data(record.content_type[:100])
            else:
                self.body = None
                self.content_length = 0
        else:
            if 'content-type' in self.headers_dict:
                self.content_type = self.headers_dict['content-type']
            else:
                self.content_type = None
            if 'content-length' in self.headers_dict:
                self.content_length = int( self.headers_dict.get('content-length') )
                self.body = self.rfile.read(self.content_length)
            else:
                self.body = None
                self.content_length = 0

        if self.content_length > 0:
            if self.filename:
                self.log_message( f'Received {self.content_length} bytes, content-type: {self.content_type} filename: {self.filename}' )
            else:
                self.log_message( f'Received {self.content_length} bytes, content-type: {self.content_type}' )

    def respond_item(self,item):
        if item:
            headers = { 'content-type' : item.info['content-type'] }
            if 'filename' in item.info:
                filename = item.info['filename']
                headers['content-disposition'] = f'attachment; filename="{filename}"'
            message = item.as_data()
            self.respond( 200, headers, message, log_message=f'Request: {item}' )
        else:
            self.respond( 200, {}, None )
            
    def respond(self,response_value, headers, content, log_message=None ):
        http_status_message = http.client.responses[response_value] if response_value in http.client.responses else 'Unknown'
        http_status_description = self.HTTP_STATUS_DESCRIPTIONS[response_value] if response_value in self.HTTP_STATUS_DESCRIPTIONS else 'Unknown'

        if content and len(content) > 100:
            if self.verbose > 1:
                self.eprint(f'Length of content ({len(content)}) was greater than 100 bytes... truncating for safer log output')
            sanitized_content = self.sanitize_data(content[:100])
        else:
            sanitized_content = self.sanitize_data(content)

        if len(headers) > 1000:
            if self.verbose > 1:
                self.eprint(f'Length of headers ({len(headers)}) was greater than 1000 chars... truncating for safer log output')
            sanitized_headers = self.sanitize_data(str(headers)[:1000])
        else:
            sanitized_headers = self.sanitize_data(str(headers))

        if self.verbose > 3:
            self.eprint(f'sanitized_content: {sanitized_content}')
            self.eprint(f'sanitized_headers: {sanitized_headers}')

        self.close_connection = True
        err_json_response = None
        # ok_json_response = None
        if response_value < 200:
            # Informational response
            self.send_response(response_value, message=http_status_message)
        elif (response_value >= 200 and response_value < 400 and
            response_value not in (http.client.NO_CONTENT,
                                   http.client.RESET_CONTENT,
                                   http.client.NOT_MODIFIED)):
            # Send non-error response to client
            # (success, or redirection)
            if log_message:
                explanation = log_message
            else:
                explanation = http_status_description
            ## Possible enhancement: Implement JSON response & receive in iOS client?
            ## (not sure how binary data would be handled in JSON response)
            # ok_json_response = (self.DEFAULT_OK_JSON_FORMAT % 
            #             {
            #             'code': int(response_value),
            #             'message': json.dumps(content),
            #             'explain': json.dumps(explanation)
            #             }
            #         )
            # self.send_response(response_value, message=http_status_message)
            if content and isinstance(content,bytes):
                resp_content_length = len(content)
            elif content:
                resp_content_length = len(content.encode( 'utf-8', 'backslashreplace' ))
            else:
                resp_content_length = 0
            # Note: Old code sent message=content, but this causes the client to
            # receive the raw content as the HTTP status message line! This
            # caused errors. We now send the actual HTTP status message as the
            # message, and send the content as the response body.
            self.send_response(response_value, message=http_status_message)
            headers.update({ 'Content-Length': str(resp_content_length) })
            # Only for logging below
            msg = f'Response: {http_status_message} - {sanitized_content}'
        else: # Error response
            if self.verbose > 2:
                # Send developer-friendly error message, but only when in very very verbose mode
                # Avoid running server in very verbose mode in production, as it
                # may leak stacktraces and other sensitive information to clients.
                msg = f'Response: {http_status_message} - {sanitized_content}'
                explanation = log_message
            else:
                # Send the generic HTTP status message and description
                msg = f'Response: {http_status_message}'
                explanation = http_status_description
            # Run everything except the response_value through json.dumps() to
            # escape special characters
            err_json_response = (self.DEFAULT_ERROR_JSON_FORMAT % 
                                 {
                                    'code': int(response_value),
                                    'message': json.dumps(msg),
                                    'explain': json.dumps(explanation)
                                 }
                                )
            # Note: We can not use send_error() here, as it will send HTML escaped character entities
            #      and we want to send raw JSON. We will have to manually send the response.
            resp_content_length = len(err_json_response.encode('utf-8', 'backslashreplace'))
            self.send_response(response_value, message=http_status_message)
            headers.update({ 'Content-Type': self.DEFAULT_ERROR_CONTENT_TYPE })
            headers.update({ 'Content-Length': str(resp_content_length) })
        ctype = None
        if headers:
            for header,value in headers.items():
                if header.lower() == 'content-type':
                    ctype = value
                    
                if self.verbose > 1:
                    self.eprint(f'Sending Header: {header}: value: {value}')
                self.send_header(header,value)
        self.end_headers()
        if err_json_response:
            self.wfile.write(err_json_response.encode('utf-8', 'backslashreplace'))
        ## Possible enhancement: Implement JSON response & receive in iOS client?
        # if ok_json_response:
        #     self.wfile.write(ok_json_response.encode('utf-8', 'replace'))
        if content and not err_json_response:
            self.wfile.write(content if isinstance(content,bytes) else content.encode( 'utf-8', 'backslashreplace' ) )
        # Always log what we responded to the client with, regardless of verbosity level
        self.eprint(f'{sanitized_content}')
        self.log_message( 'Response: %s - %s - %s, %d bytes, %s', response_value, msg, explanation, resp_content_length if resp_content_length else 0, sanitized_headers )
        # OLD f-string caused "%" format string errors in BaseHTTPRequestHandler.log_message()
        #   self.log_message( f'Response: {response_value} - {msg} - {explanation}, {len(content) if content else 0} bytes, {headers}' )
        
class RemoteStash:
    def __init__(self,args=None):
        self.args = args
        self.verbose = args.verbose

    def listen_and_execute(self,path = 'last'):
        '''
        listen to find a server to execute the action in path
        after given timeout if no service found will exit with an error
        '''
        zeroconf = Zeroconf()
        listener = RemoteStashClient(path,self)
        if path == 'push':
            (filename,inputf) = self.get_input_file()
            if inputf:
                listener.filename = filename
                listener.content = inputf.read()
                listener.outfile = None
            else:
                print( "Failed to open input file" )
                listener = None
        else:
            listener.filename = None
            listener.content = None
            listener.outfile = None

        if listener:
            listener.content_type = self.get_input_content_type()
            browser = ServiceBrowser(zeroconf, "_remotestash._tcp.local.", listener)
            time.sleep(self.args.timeout)
            if path != 'list':
                print( 'Failed to find a stash on the local network'  )

    def cmd_serve(self):
        '''
        Will start a local server that will advertise over ZeroConf the service
        and start a web server to enable remote access to the local stash
        '''
        ensure_remote_stash_dir('~/.remotestash')
        zeroconf = Zeroconf()
        advertiser = RemoteStashServerAdvertiser(int(self.args.port) if self.args.port else None)
        if self.args.name:
            name = self.args.name
        else:
            name = f'{advertiser.get_name()} RemoteStash'
        advertiser.start_advertisement(name)
        port = advertiser.port
        # Pass in this RemoteStash instance to the server class, so it can access the self.verbose attribute
        server = RemoteStashServer((advertiser.ip, port), self)
        if self.verbose > 1:
            print( f'Server object: {server}')
        proto = 'http'
        if os.path.isfile( os.path.expanduser( '~/.remotestash/remotestash-key.pem' ) ):
            proto = 'https'
            # certificate created with
            # Will check consistency with the certificate used on other server/app
            #  openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout remotestash-key.pem -out remotestash-cert.pem
            # Replace deprecated ssl.wrap_socket() with ssl.SSLContext.wrap_socket() for Python 3.7 and later
            python_ver = (sys.version_info[0], sys.version_info[1])
            if python_ver >= (3,7):
                context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
                context.check_hostname = False
                context.load_cert_chain( os.path.expanduser( '~/.remotestash/remotestash-cert.pem' ),
                                         os.path.expanduser( '~/.remotestash/remotestash-key.pem' ) )
                server.socket = context.wrap_socket( server.socket, server_side=True )
            else:
                server.socket = ssl.wrap_socket( server.socket,
                                                 keyfile = os.path.expanduser( '~/.remotestash/remotestash-key.pem' ),
                                                 certfile = os.path.expanduser( '~/.remotestash/remotestash-cert.pem' ),
                                                 server_side = True )
        else:
            print( "Couldn't find certificate and key files, please copy the files in the certs directory into ~/.remotestash to continue")
            exit(1)
            
        print(f"Starting server as '{name}' on {proto}://{advertiser.ip}:{port}, use <Ctrl-C> to stop")
        try:
            while True:
                server.handle_request()
        finally:
            advertiser.clean_advertisement()

    def get_input_file(self):
        if 'file' in self.args and self.args.file:
            if os.path.isfile( self.args.file ):
                return (os.path.basename(self.args.file),  open( self.args.file, 'rb' ))
            else:
                return (None,None)
        else:
            return (None,sys.stdin)
        
    def get_input_content_type(self):
        if self.args.content_type:
            return self.args.content_type

        if 'file' in self.args and self.args.file:
            if os.path.isfile( self.args.file ):
                ct = mimetypes.guess_type( self.args.file )
                if ct[1]:
                    ct = f'{ct[0]}; charset: {ct[1]}'
                else:
                    ct = ct[0]
                return( ct )
            
        return 'text/plain; charset=utf-8'
        
    def get_output_file(self,item=None):
        '''
        return a file handle of where the output of an item should be written to
        stdout or if applicable the filename from the original item will be use unless overwritten 
        on the command line. '-' as a file name will force output to stdout
        '''
        if item and self.verbose:
            pprint( item )

        if 'file' in self.args and self.args.file:
            if self.args.file == '-':
                if self.verbose:
                    print( 'Sending to stdout' )
                return sys.stdout
            else:
                if self.verbose:
                    print( f'Saving to {self.args.file}' )
                return open( self.args.file, 'wb' )
        else:
            # if no args, just use stdout or filename provided by item
            if item and item.filename():
                if self.verbose:
                    print( f'Saving to {item.filename()}' )
                return open( item.filename(), 'wb' )
            else:
                if self.verbose:
                    print( 'Sending to stdout' )
                return sys.stdout
            
    def cmd_push(self):
        if self.args.local:
            (filename,inputf) = self.get_input_file()
            content_type = self.get_input_content_type()

            info = {'content-type': content_type }
            if filename:
                info['filename'] = filename
                        
            item = RemoteStashItem.from_file( info, inputf )
            stash = RemoteStashLocal(self.args)
            stash.push( item )
        else:
            self.listen_and_execute('push')

    def cmd_pull(self):
        if self.args.local:
            stash = RemoteStashLocal(self.args)
            item = stash.pull()
            if item:
                item.output(self.get_output_file())
        else:
            self.listen_and_execute('pull')
            
    def cmd_last(self):
        if self.args.local:
            stash = RemoteStashLocal(self.args)
            item = stash.last()
            if item:
                item.output(self.get_output_file())
            else:
                if self.verbose:
                    print( 'Local Stash empty no last item' )
        else:
            self.listen_and_execute('last')
            
    def cmd_status(self):
        if self.args.local:
            stash = RemoteStashLocal(self.args)
            status = stash.status()
            item = RemoteStashItem.from_json( json.dumps( status ) )
            item.output( self.get_output_file() )
        else:
            self.listen_and_execute('status')

    def cmd_list(self):
        if self.args.local:
            stash = RemoteStashLocal(self.args)
            status = stash.list()
        else:
            self.listen_and_execute('list')
            
    def cmd_clean(self):
        if self.args.local:
            stash = RemoteStashLocal(self.args)
            stash.clean()
        else:
            print( 'Clean not implemented for remote' )
            
    def cmd_clear(self):
        if self.args.local:
            stash = RemoteStashLocal(self.args)
            status = stash.clear()
        else:
            print( 'Clear not implemented for remote' )

    def cmd_test(self):
        a = RemoteStashItem.from_string( 'hello', { 'content-type': 'text/plain; charset=utf-8' } )

        print( a.as_data() )
        print( a.as_str() )
        
            
if __name__ == "__main__":
    commands = {
        'serve':{'attr':'cmd_serve','help':'start server'},
        'push':{'attr':'cmd_push','help':'push content to stash'},
        'last':{'attr':'cmd_last','help':'get last content from the stash without removing it'},
        'pull':{'attr':'cmd_pull','help':'pull content from the stash'},
        'list':{'attr':'cmd_list','help':'list available stash'},
        'clean':{'attr':'cmd_clean','help':'clean stash from unused assets'},
        'status':{'attr':'cmd_status','help':'status of stash'},
        'test':{'attr':'cmd_test','help':'random tests'},
        'clear':{'attr':'cmd_clear','help':'clear stash (local only)'},
    }
    
    description = "\n".join( [ '  {}: {}'.format( k,v['help'] ) for (k,v) in commands.items() ] )
    
    parser = argparse.ArgumentParser( description='RemoteStash exchange files and data between devices', formatter_class=argparse.RawTextHelpFormatter )
    parser.add_argument( 'command', help='command to execute:\n' + description)
    parser.add_argument( '-c', '--content-type', help='content type' )
    parser.add_argument( '-l', '--local', action='store_true', help='use local stash' )
    parser.add_argument( '-n', '--name', help='name for service' )
    parser.add_argument( '-v', '--verbose', action='count', default=False, help='verbose output. Pass multiple times to be very verbose and display more debug info. Supports up to 5 -v flags.' )
    parser.add_argument( '-p', '--port', help='port to use if not set will use a free port' )
    parser.add_argument( '-t', '--timeout', help='timeout for searching for a RemoteStash on the network', default=5.0, type=float )
    parser.add_argument( 'file',nargs='?', help='file name to read or save, empty or - for stdout/stdin' )
    args = parser.parse_args()

    command = RemoteStash(args)

    if args.command in commands:
        getattr(command,commands[args.command]['attr'])()
    else:
        print( 'Invalid command "{}"'.format( args.command) )
        parser.print_help()
